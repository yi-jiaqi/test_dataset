<!DOCTYPE html>
<html>
<head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #333;
      color: white;
      font-family: Arial, sans-serif;
    }
    #controls {
      margin: 10px;
      padding: 10px;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    button {
      padding: 8px 15px;
      background-color: #444;
      color: white;
      border: 1px solid #666;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #555;
    }
    select {
      padding: 8px;
      background-color: #444;
      color: white;
      border: 1px solid #666;
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <button id="resetBtn">Reset Sketch</button>
    <select id="aspectRatio">
      <option value="9:21">9:21 (Default)</option>
      <option value="3:5">3:5</option>
      <option value="9:16">9:16</option>
      <option value="1:1">1:1 (Square)</option>
      <option value="16:9">16:9 (Widescreen)</option>
    </select>
  </div>
  <script>
    let canvasWidth = 540;  // Default width for 9:21 ratio
    let canvasHeight = 1260; // Default height for 9:21 ratio
    let gcdValue = 1;
    let circles = [];
    let lastFrameTime = 0;
    const vibrationSpeed = 0.1;

    function setup() {
      createCanvas(canvasWidth, canvasHeight);
      calculateGCD();
      createGridCircles();
      
      // Setup controls
      document.getElementById('resetBtn').addEventListener('click', resetSketch);
      document.getElementById('aspectRatio').addEventListener('change', changeAspectRatio);
    }

    function draw() {
      background(0);
      drawGrid();
      drawCircles();
	//   noLoop();
    }

    function calculateGCD() {
      gcdValue = gcd(canvasWidth, canvasHeight);
    }

    function gcd(a, b) {
      // Euclidean algorithm to find GCD
      while (b !== 0) {
        let temp = b;
        b = a % b;
        a = temp;
      }
      return a;
    }

    function drawGrid() {
      stroke(255);
      strokeWeight(0.4);
      
      const cols = canvasWidth / gcdValue;
      const rows = canvasHeight / gcdValue;
      const cellWidth = canvasWidth / cols;
      const cellHeight = canvasHeight / rows;
      
      // Draw vertical lines
      for (let i = 0; i <= cols; i++) {
        line(i * cellWidth, 0, i * cellWidth, canvasHeight);
      }
      
      // Draw horizontal lines
      for (let j = 0; j <= rows; j++) {
        line(0, j * cellHeight, canvasWidth, j * cellHeight);
      }
    }

    function createGridCircles() {
      circles = [];
      const cols = canvasWidth / gcdValue;
      const rows = canvasHeight / gcdValue;
      const cellWidth = canvasWidth / cols;
      const cellHeight = canvasHeight / rows;
      
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < rows; j++) {
          const x = i * cellWidth + cellWidth / 2;
          const y = j * cellHeight + cellHeight / 2;
          const radius = min(cellWidth, cellHeight) * 0.4;
          const hue = random(0, 360);
          
          circles.push({
            x: x,
            y: y,
            radius: radius,
            hue: hue,
            baseStrokeWeight: random(1, 3)
          });
        }
      }
    }

    function drawCircles() {
      const time = millis() * 0.001; // Convert to seconds
      
      for (let circle of circles) {
        // Vibrating stroke weight
        const sw = circle.baseStrokeWeight + sin(time * vibrationSpeed + circle.x) * 1.5;
        
        // Rainbow color
        fill(circle.hue, 80, 90);
        stroke(circle.hue, 100, 100);
        strokeWeight(sw);
		noFill()
        
        ellipse(circle.x, circle.y, circle.radius * 2);
      }
    }

    function resetSketch() {
      calculateGCD();
      createGridCircles();
    }

    function changeAspectRatio() {
      const ratio = document.getElementById('aspectRatio').value;
      const [w, h] = ratio.split(':').map(Number);
      
      // Calculate new dimensions while maintaining reasonable size
      const scaleFactor = 60; // Adjust this to change the overall size
      canvasWidth = w * scaleFactor;
      canvasHeight = h * scaleFactor;
      
      resizeCanvas(canvasWidth, canvasHeight);
      resetSketch();
    }

    function windowResized() {
      // Optional: handle window resizing if needed
    }
  </script>
</body>
</html>
